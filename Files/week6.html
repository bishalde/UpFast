
<html lang="en">
<head>
    <title>Week 6</title>
</head>
<body>
    <pre>
        # -*- coding: utf-8 -*-
"""Lab - Week6,Experiment6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VmJMVQzySl-2m_IWoqHCZQrWlXApFtPX
"""

# Commented out IPython magic to ensure Python compatibility.
from qiskit import *
import matplotlib.pyplot as plt
# %matplotlib inline
from qiskit.visualization import plot_histogram

qc = QuantumCircuit(4,2)
# encode inputs in qubits 0 and 1
qc.x(0) #flips 1st qubit to 1
qc.x(1) #flips 2nd qubit to 1 since we want to perform the addition 1+1

# use cnots to write the XOR of the inputs on qubit 2
qc.cx(0,2)
qc.cx(1,2)

# extract outputs
qc.measure(2,0) # extract XOR value
qc.measure(3,1)

qc.draw(output='mpl')

qc = QuantumCircuit(4,2)
# encode inputs in qubits 0 and 1
qc.x(0)
qc.x(1)
# use cnots to write the XOR of the inputs on qubit 2
qc.cx(0,2)
qc.cx(1,2)
# use ccx to write the AND of the inputs on qubit 3
qc.ccx(0,1,3)
# extract outputs
qc.measure(2,0) # extract XOR value
qc.measure(3,1) # extract AND value

qc.draw(output='mpl')

from qiskit import *
from qiskit.tools.visualization import plot_bloch_multivector
from qiskit.tools.visualization import plot_histogram

# Creating a circuit with 8 quantum bits and 2 classical bits
qc = QuantumCircuit(8,2)

# Preparing inputs
qc.x(0) # Comment this line to make Qbit0 = |0>
qc.x(1) # Comment this line to make Qbit1 = |0>
qc.x(2) # Comment this line to make Qbit2 = |0> ( carry-in bit )
qc.barrier()

# AND gate1 implementation
qc.ccx(0,1,3)
qc.barrier()

# OR gate1 implementation
qc.cx(0,4)
qc.cx(1,4)
qc.barrier()

# OR gate2 implementation
qc.cx(2,5)
qc.cx(4,5)
qc.barrier()

# AND gate2 implementation
qc.ccx(2,4,6)
qc.barrier()

# OR gate implementation
qc.x(3)
qc.x(6)
qc.ccx(3,6,7)
qc.x(7)
qc.barrier()

# Measuring and put result to classical bit
qc.measure(5,0) # ( sum )
qc.measure(7,1) # ( carry-out )

# Run the experimient 1024 times and get stats
counts = execute(qc,Aer.get_backend('qasm_simulator')).result().get_counts()
print(counts)
qc.draw(output='mpl')

# Commented out IPython magic to ensure Python compatibility.
from qiskit import *
import matplotlib.pyplot as plt
# %matplotlib inline
from qiskit.visualization import plot_histogram
counts = execute(qc,Aer.get_backend('qasm_simulator')).result().get_counts()
plot_histogram(counts)

from qiskit import QuantumCircuit, Aer, transpile, assemble, execute
from qiskit.visualization import plot_histogram

def quantum_half_subtractor():
    qc = QuantumCircuit(4, 2)

    # Input bits
    qc.x(0)  # Set A = 1
    qc.x(1)  # Set B = 1

    # Perform subtraction
    qc.cx(0, 2)  # CNOT to calculate difference
    qc.cx(1, 2)

    qc.x(0)  # Uncompute A
    qc.x(2)  # Uncompute D

    # Calculate borrow
    qc.cx(0, 3)
    qc.cx(1, 3)

    # Measure difference and borrow
    qc.measure(2, 0)  # Measure D into the first classical bit
    qc.measure(3, 1)  # Measure Bout into the second classical bit

    return qc

# Simulate the half subtractor circuit
half_subtractor_circuit = quantum_half_subtractor()
simulator = Aer.get_backend('qasm_simulator')
compiled_circuit = transpile(half_subtractor_circuit, simulator)
job = execute(compiled_circuit, simulator, shots=1024)
result = job.result()

# Plot the histogram of measurement results
counts = result.get_counts()
plot_histogram(counts)
half_subtractor_circuit.draw(output='mpl')

#full substractor
from qiskit import QuantumCircuit, Aer, transpile, execute
from qiskit.visualization import plot_histogram

def quantum_full_subtractor():
    qc = QuantumCircuit(5, 2)

    # Input bits
    qc.x(0)  # Set A = 1
    qc.x(1)  # Set B = 1
    qc.x(2)  # Set Bin = 1

    # Calculate the borrow for the least significant bit
    qc.ccx(0, 1, 3)
    qc.ccx(0, 2, 3)

    # Calculate the difference for the least significant bit
    qc.cx(0, 4)
    qc.cx(1, 4)
    qc.cx(2, 4)

    # Calculate the borrow for the most significant bit
    qc.ccx(1, 2, 3)

    # Calculate the difference for the most significant bit
    qc.cx(1, 4)
    qc.cx(2, 4)

    # Measure difference and borrow
    qc.measure(4, 0)  # Measure D into the first classical bit
    qc.measure(3, 1)  # Measure Bout into the second classical bit

    return qc

# Simulate the full subtractor circuit
full_subtractor_circuit = quantum_full_subtractor()
simulator = Aer.get_backend('qasm_simulator')
compiled_circuit = transpile(full_subtractor_circuit, simulator)
job = execute(compiled_circuit, simulator, shots=1024)
result = job.result()

# Plot the histogram of measurement results
counts = result.get_counts()
plot_histogram(counts)
from qiskit import QuantumCircuit, Aer, transpile, execute
from qiskit.visualization import plot_histogram

def quantum_full_subtractor():
    qc = QuantumCircuit(5, 2)

    # Input bits
    qc.x(0)  # Set A = 1
    qc.x(1)  # Set B = 1
    qc.x(2)  # Set Bin = 1

    # Calculate the borrow for the least significant bit
    qc.ccx(0, 1, 3)
    qc.ccx(0, 2, 3)

    # Calculate the difference for the least significant bit
    qc.cx(0, 4)
    qc.cx(1, 4)
    qc.cx(2, 4)

    # Calculate the borrow for the most significant bit
    qc.ccx(1, 2, 3)

    # Calculate the difference for the most significant bit
    qc.cx(1, 4)
    qc.cx(2, 4)

    # Measure difference and borrow
    qc.measure(4, 0)  # Measure D into the first classical bit
    qc.measure(3, 1)  # Measure Bout into the second classical bit

    return qc

# Simulate the full subtractor circuit
full_subtractor_circuit = quantum_full_subtractor()
simulator = Aer.get_backend('qasm_simulator')
compiled_circuit = transpile(full_subtractor_circuit, simulator)
job = execute(compiled_circuit, simulator, shots=1024)
result = job.result()

# Plot the histogram of measurement results
counts = result.get_counts()
plot_histogram(counts)

full_subtractor_circuit.draw()


    </pre>
</body>
</html>